'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

var calculateTotalDuration = ({ duration = 0.3, delay = 0, overlay = 0, }) => duration + delay - overlay || 0;

function getSequenceId(sequenceIndex, sequenceId, defaultValue) {
    if (sequenceId === undefined && sequenceIndex === undefined)
        return defaultValue || 0;
    if (sequenceIndex && sequenceIndex >= 0)
        return sequenceIndex;
    if (sequenceId)
        return sequenceId;
    return 0;
}

const { useState, useRef, useEffect } = React;
const AnimateContext = React.createContext({
    animationStates: {},
    register: (data) => { },
});
function AnimateGroup(props) {
    const { play, sequences = [], children } = props;
    const [animationStates, setAnimationStates] = useState();
    const animationsRef = useRef({});
    const register = (data) => {
        const { sequenceIndex, sequenceId } = data;
        if (sequenceId === undefined && sequenceIndex === undefined)
            return;
        animationsRef.current[getSequenceId(sequenceIndex, sequenceId)] = data;
    };
    useEffect(() => {
        const sequencesToAnimate = Array.isArray(sequences) && sequences.length ? sequences : Object.values(animationsRef.current);
        const localAnimationState = {};
        (play ? sequencesToAnimate : [...sequencesToAnimate].reverse()).reduce((previous, current, currentIndex) => {
            const { sequenceId, sequenceIndex } = current, restAttributes = __rest(current, ["sequenceId", "sequenceIndex"]);
            const { duration, delay, overlay } = restAttributes;
            const id = getSequenceId(sequenceIndex, sequenceId, currentIndex);
            const totalDuration = calculateTotalDuration({ duration, delay, overlay }) + previous;
            localAnimationState[id] = {
                play,
                delay: currentIndex === 0 ? delay || 0 : previous,
            };
            return totalDuration;
        }, 0);
        setAnimationStates(localAnimationState);
    }, [play]);
    // @ts-ignore
    return (React.createElement(AnimateContext.Provider, { value: { animationStates, register } }, children));
}

var msToSec = (ms) => (ms || 0) * 1000;

const { useEffect: useEffect$1, useState: useState$1, useRef: useRef$1, useContext } = React;
function Animate(props) {
    const { play, children, render, start, end, complete = '', onComplete, delay = 0, duration = 0.3, easeType = 'linear', sequenceId, sequenceIndex, } = props;
    const onCompleteTimeRef = useRef$1(null);
    const [style, setStyle] = useState$1(start || {});
    const { register, animationStates = {} } = useContext(AnimateContext);
    const id = getSequenceId(sequenceIndex, sequenceId);
    useEffect$1(() => {
        if ((sequenceIndex !== undefined && sequenceIndex >= 0) || sequenceId)
            register(props);
    }, []);
    useEffect$1(() => {
        setStyle(Object.assign({}, (play || (animationStates[id] || {}).play ? end : start), { transition: `all ${duration}s ${easeType} ${parseFloat((animationStates[id] || {}).delay || delay)}s` }));
        if (play && (complete || onComplete)) {
            // @ts-ignore
            onCompleteTimeRef.current = setTimeout(() => {
                complete && setStyle(complete);
                onComplete && onComplete();
            }, msToSec(parseFloat((animationStates[id] || {}).delay || delay) + duration));
        }
        return () => {
            // @ts-ignore
            onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
        };
    }, [id, animationStates, play, duration, easeType, delay, onComplete, start, end, complete]);
    return render ? render({ style }) : React.createElement("div", { style: style }, children);
}

function createStyle({ keyframes, animationName, }) {
    const animationLength = keyframes.length;
    return `${keyframes.reduce((previous, keyframe, currentIndex) => {
        if (keyframe) {
            return `${previous} ${animationLength === 2 ? currentIndex * 100 : parseFloat((100 / (animationLength - 1)).toFixed(2)) * currentIndex}% {${keyframe}}`;
        }
        return `${previous} ${Object.keys(keyframe)[0]}% {${Object.values(keyframe)[0]}}`;
    }, `@keyframes ${animationName} {`)}}`;
}

function createTag({ keyframes, animationName, }) {
    let styleTag = document.querySelector('style[data-id=rsi]');
    let index = 0;
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.setAttribute('data-id', 'rsi');
        document.head.appendChild(styleTag);
    }
    try {
        // @ts-ignore
        index = styleTag.sheet.cssRules.length;
    }
    catch (e) {
        index = 0;
    }
    try {
        // @ts-ignore
        styleTag.sheet.insertRule(createStyle({
            keyframes,
            animationName,
        }), index);
    }
    catch (e) {
        console.error('react simple animate, error found during insert style ', e); // eslint-disable-line no-console
    }
    return {
        styleTag,
        index,
    };
}

var createRandomName = () => `RSI-${Math.random()
    .toString(36)
    .substr(2, 9)}`;

var deleteRules = (sheet, deleteName) => {
    const index = Object.values(sheet.cssRules).findIndex(({ name }) => name === deleteName);
    if (index >= 0)
        sheet.deleteRule(index);
};

const { useRef: useRef$2, useEffect: useEffect$2, useContext: useContext$1, useState: useState$2 } = React;
function AnimateKeyframes(props) {
    const { children, play, render, duration = 0.3, delay = 0, easeType = 'linear', playState = 'running', direction = 'normal', fillMode = 'none', iterationCount = 1, keyframes, } = props;
    const animationNameRef = useRef$2('');
    const styleTagRef = useRef$2({
        sheet: {},
    });
    const { register } = useContext$1(AnimateContext);
    const forceUpdate = useState$2(false)[1];
    useEffect$2(() => {
        animationNameRef.current = createRandomName();
        const { styleTag } = createTag({
            animationName: animationNameRef.current,
            keyframes,
        });
        styleTagRef.current = styleTag;
        register(props);
        if (play)
            forceUpdate(true);
        return () => deleteRules(styleTagRef.current.sheet, animationNameRef.current);
    }, []);
    const style = play
        ? {
            animation: `${duration}s ${easeType} ${delay}s ${iterationCount} ${direction} ${fillMode} ${playState} ${animationNameRef.current ||
                ''}`,
        }
        : null;
    return render ? render({ style }) : React.createElement("div", { style: style || {} }, children);
}

function useAnimate(props) {
    const { start, end, complete, onComplete, delay = 0, duration = 0.3, easeType = 'linear' } = props;
    const transition = `all ${duration}s ${easeType} ${delay}s`;
    const [style, setStyle] = React.useState(Object.assign({}, start, { transition }));
    const [isPlaying, setIsPlaying] = React.useState(false);
    const onCompleteTimeRef = React.useRef(0);
    React.useEffect(() => () => {
        onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
    }, []);
    const play = (isPlay) => {
        setStyle(Object.assign({}, (isPlay ? end : start), { transition }));
        setIsPlaying(isPlay);
        if (isPlay && (complete || onComplete)) {
            // @ts-ignore
            onCompleteTimeRef.current = setTimeout(() => {
                // @ts-ignore
                complete && setStyle(complete);
                onComplete && onComplete();
            }, msToSec(delay + duration));
        }
    };
    return {
        isPlaying,
        style,
        play,
    };
}

function useAnimateKeyframes(props) {
    const { duration = 0.3, delay = 0, easeType = 'linear', direction = 'normal', fillMode = 'none', iterationCount = 1, playState = 'running', keyframes, } = props;
    const animationNameRef = React.useRef('');
    const styleTagRef = React.useRef('');
    const { register } = React.useContext(AnimateContext);
    const [isPlaying, setIsPlaying] = React.useState(false);
    React.useEffect(() => {
        animationNameRef.current = createRandomName();
        const { styleTag } = createTag({
            animationName: animationNameRef.current,
            keyframes,
        });
        styleTagRef.current = styleTag;
        register(props);
        // @ts-ignore
        return () => deleteRules(styleTagRef.current.sheet, animationNameRef.current);
    }, []);
    const play = (isPlay) => {
        setIsPlaying(isPlay);
    };
    const style = isPlaying
        ? {
            animation: `${duration}s ${easeType} ${delay}s ${iterationCount} ${direction} ${fillMode} ${playState} ${animationNameRef.current ||
                ''}`,
        }
        : null;
    return {
        style,
        play,
        isPlaying,
    };
}

function createArrayWithNumbers(length) {
    return Array.from({ length }, () => null);
}
function useAnimateGroup(props) {
    const { sequences = [] } = props;
    const defaultArray = createArrayWithNumbers(sequences.length);
    const [styles, setStyles] = React.useState(defaultArray);
    const [isPlaying, setPlaying] = React.useState(false);
    const animationNamesRef = React.useRef({});
    React.useEffect(() => {
        let localStyleTag;
        // @ts-ignore
        sequences.forEach(({ keyframes = false }, i) => {
            if (!Array.isArray(keyframes))
                return;
            const animationName = createRandomName();
            animationNamesRef.current[i] = animationName;
            const { styleTag } = createTag({ animationName, keyframes });
            localStyleTag = styleTag;
        });
        return () => {
            if (!localStyleTag)
                return;
            Object.values(animationNamesRef).forEach(name => {
                deleteRules(localStyleTag.sheet, name);
            });
        };
    }, []);
    const play = (isPlay) => {
        let totalDuration = 0;
        const styles = (isPlay ? sequences : [...sequences].reverse()).map((current, currentIndex) => {
            const { duration = 0.3, delay = 0, overlay, keyframes, iterationCount = 1, easeType = 'linear', playState = 'running', direction = 'normal', fillMode = 'none', end = {}, start = {}, } = current;
            const delayDuration = currentIndex === 0 ? delay : totalDuration;
            totalDuration = calculateTotalDuration({ duration, delay, overlay }) + totalDuration;
            if (keyframes) {
                return isPlay
                    ? {
                        animation: `${duration}s ${easeType} ${delayDuration}s ${iterationCount} ${direction} ${fillMode} ${playState} ${animationNamesRef.current[currentIndex]}`,
                    }
                    : {};
            }
            const transition = `all ${duration}s ${easeType} ${delayDuration}s`;
            return Object.assign({}, (isPlay ? end : start), { transition });
        });
        // @ts-ignore
        setStyles(isPlay ? styles : [...styles].reverse());
        setPlaying(!isPlaying);
    };
    return { styles, play, isPlaying };
}

exports.Animate = Animate;
exports.AnimateGroup = AnimateGroup;
exports.AnimateKeyframes = AnimateKeyframes;
exports.useAnimate = useAnimate;
exports.useAnimateGroup = useAnimateGroup;
exports.useAnimateKeyframes = useAnimateKeyframes;
